## EDL (Equipment description language)
### version v0.0.1a-1
Альфа версия (прототип) декларативного шаблонизатора для описания оборудования и генерации
(на момент текущей версии) данных в формат целевой платформы

### Потенциальные возможности
* генерация документации оборудования;
* генерация SQL скриптов для формирования таблиц данных реляционных БД;
* генерация объектов на языках общего назначения (python, go, etc);
* генерация конфигураций для систем мониторинга;

### Описание работы (кратко)
Процесс трансляции представляет собой пять этапов:
1. Препроцессинг - возможность подстановки в код данных из внешних файлов и создание символов для их хранения  
2. Лексический анализ - токенизация лексем, проверка их корректности / допустимости
3. Синтаксический анализ - проверка корректности выражений
4. Семантический анализ - проверка допустимости выражений, проверка разрешения символов, анализ типов.
5. Трансляция - трансляция EDL абстракций в целевой формат.
6. Постпроцессинг (отсутствует) - проверка корректности финальных данных с точки зрения целевой платформы (валидация).

Подразумевается множество трансляторов, как плагинов для EDL, каждый из которых умеет
преобразовывать абстракции EDL в язык целевой платформы.

* Синтаксический анализ - строим AST;  
* Семантический анализ - строим ADT на основе AST;  
* Трансляция - транслируем ADT в целевой формат.

Лексеры и Парсеры имеют трассировку. Парсер препроцессора не строит AST

См. EBNF грамматики для EDL для понимания синтаксиса

### Порядок разрешения символов
#### Общий
1. переменные
2. директивы
3. параметры
4. объекты

#### Глобальный (уровень модуля)
1. переменные
2. директивы (они могут использовать значение переменной)
3. объекты -> (шаблон, оборудование, сигнал, соединение)

#### Шаблон (уровень шаблона)
Шаблон - это область видимости, в которой можно создать объект контекста для
генерации множества шаблонных данных используя данные из внешнего источника
1. контекст
2. переменные
3. директивы
4. параметры
5. соединения (как отдельный объект, так как их могут использовать другие объекты)
5. объекты

Контекст рушит иерархическую структуру объекта, создавая из нее линейную.
Можно создавать множество контекстов, один объект может использовать (пока) только один контекст.

Контекст представляет собой область переменных, значения которым присваиваются итеративно из данных внешнего источника.
контекст виден глобально всем объекта внутри шаблона. В текущая реализация предполагает, что переданные ей внешние данные - это
контекстно связанные и контекстно валидные данные для всех объектов в использующих контекст.

Объект может использовать контекст с помощью директивы 'использовать'

#### Оборудование
область видимости для описания оборудования.
1. переменные
2. директивы
3. параметры
4. соединения
5. блоки

#### Соединение
Запрещено создание соединений из контекста и запрещено использование в них директивы 'использовать'
На данный момент результат таких действий не определен.
(директив для соединения пока нет)
1. переменные
2. директивы
3. параметры

Для привязки соединения создан специальный объект - Link -> ConnectionLink
Объект хранит имя соединения, к которому осущствляется привязка, а также сам объект.
Объект связанный соединением находит его по имени (lookup()) и получает его идентификатор.

(также есть возможность динамически конфигурировать имя с использованием переменных - TODO)
Нужно разрешать имена переменных в момент перехода с AST в ADT

ConnectionLink также реализует visitor (метод visit)

#### Сигнал
1. переменные
2. директивы
3. параметры
4. соединения (?)

Сигнал - это область видимости (параметры) которыми можно описать абстрактный сигнал 

### Нереализованные пункты / ошибки / техдолг / особенности
1. Обработка типов диапазонов (типизация) - сейчас типы не проверяются на стадии ADT, игнорируются или не допускаются значения float и
    представление бесконечных значений (-inf -> inf);
2. Нет проверки типов массивов - есть генерация описания типа массива (например arr[str:6, arr[int:7]..]). Оттутствует проверка типов в переданном массиве 
в качестве дынных;
3. Нет реализации правил (распаковка данных);
4. Нет реализации фильтров значений в директиве 'использовать';
5. Нет реализации правил (rule) подстановки данных в строки;
6. При нескольких адресах в соединении и указании обработчиков, последний указанный перезаписывает предыдущий (нет правил / ограничений на этот счет);
7. Нет возможности именовать форматы для значений и тревог (сейчас генерируются машинно). Поэтому на каждый объект сейчас генерируется один зависимый объект (кроме соединений);
8. Visitor реализован не в полном объеме - в некоторые ноды не заходим ни в AST ни в ADT (в том числе поэтому пока нет реализации проверки типов массива и диапазона)
9. Нет понимания, как лучше привязывать вложенные объекты к внешним (если не используется контекст)
10. Обработка конкретных операций в трансляторе DynamicScope в который функция верхнего уровня выставляет нужные значения а обработчики параметров их корректируют удаляют итд (не самая лучшая идея)
11. Не реализовано формирование формата сообщения о тревоге и формат сообщения из стандартных полей (формат пока большей частью хардкодный)
12. Внешние данные поддерживаются только в формате arr[arr[any..]..]. Количество элементов (и их типы) должны совпадать с количеством переменных контекста.

### Особенности
#### Массив
* arr[] - пустой  
* arr[int] - с одним элементом  
* arr[int:3, str:2] - с тремя int и двумя str  
* arr[int:4, arr[int:10]..] - из четырех int и множества массивов с 10 int  
* arr[arr[int..]..] - неопределенное количество массивов с неопределенным количеством int
* .. - эллипсис, возможен только как заключительный символ описания массива. Сообщает что количество может быть любым

#### Диапазон
позволяет описывать диапазон значений.
Представим как тип float и как тип int.  

* диапазон[~, ~] - "-inf" -> "+inf" (float)  
* диапазон[2, 7] - диапазон от 2 до 7   
* диапазон[~, 10], диапазон[20, ~]  

### Запуск
#### проверка результатов работы препроцессора
Флаг `-e` подволяет прервать выполнение после стадии препроцессинга и сохранить результаты препроцессинга в файл.
Команда запустит препроцессор на выбранном файле и после завершения стадии препроцессинга сохранит результат в текущую директорию в файл `out.txt`
```bash
python edl.py -e -f example_with_ctx.edl
```  
Команда запустит препроцессор на выбранном файле и после завершения стадии препроцессинга сохранит результат в указанную директорию в файл `out.txt`
```bash
python edl.py -e -f example_with_ctx.edl --output-path=old_bcp
```

#### Компиляция (v0.0.1a-1)
Скомпилирует файл в целевые файлы `nano-scada` в указанную директорию
```bash
python edl.py -f example_with_ctx.edl --output-path=old_bcp
```

#### Конфигурация
```bash
mv edl.py edl
sudo chmod +x edl
sudo ln -s $(pwd)/edl /usr/local/bin/
```